%============================== gaitHilare01_IPOPT =============================
%
% @brief    Test script for the kinemetic Hilare robot model.
%
%
% Original file is gaitHilare01.m. This file modifies the optimization solver to 
% use the IPOPT instead of SNOPT. 
%
% REMARK: 
%  The piecewise constant B-spline is specified in Optragen by 
%  traj(ninterv,0,1) and a piecewise linear continuous function can be
%  generated by traj(ninterv,1,2).
%
%=============================== gaitHilare01_IPOPT ==============================

%
% @file     gaitHilare01.m
%
% @author   Nak-seung Patrick Hyun,     nhyun3@gatech.edu
%           
% @date     2016/12/29 [created]
%
%=============================== gaitHilare01_IPOPT ==============================

%
%==[0] Set environment.
addpath('/home/manny/Documents/Manny')
addpath('/home/manny/Documents/Manny/Optragen/src')
addpath('/home/manny/Documents/Manny/Optragen')
% MATLIBS = {'/home/manny/Documents/control-master/Optragen','/home/manny/Documents/control-master/Optragen/src'};
% ivalab.loadLibraries(MATLIBS);
addpath('autogen');


%
%==[1] Create the problem.
%
T = pi/3;
d =  1/8;
ninterv = 5;
tfinal  = ninterv*T;

g0 = [-2.11 ;  0.11; pi/4];
pF = [ 0.22 ; -0.22];

u0 = 1.1; uf= 2.1;
uLims = [-8,  8];
wLims = [-pi/2 ; pi/2];

r1 = 0.5;
r1safe = r1+1.2*d;
rCent = [-1; 0];

smoothv = 2;
orderv  = 4;

scale = 100;

%
%==[2] Define the optimization variables.
%
%-- Robot state and input variables.
%   Since theta is directly controlled, leave derivative unconstrained.
%
gSym = {'x'; 'y'; 'th'};
gpSym = {'xd'; 'yd'; 'thd'};

x  = traj(gSym{1}, ninterv,smoothv,orderv); 
y  = traj(gSym{2}, ninterv,smoothv,orderv);
th = traj(gSym{3}, ninterv,1,2);

%-- State derivatives.
%
xd  =  x.deriv(gpSym{1});
yd  =  y.deriv(gpSym{2});
thd = th.deriv(gpSym{3});

%-- Control input: forward speed.
v  = traj('v', ninterv,0,1);

%-- Trajectory variables used in problem
%
TrajList = traj.trajList(x, xd, y, yd, th, thd, v);
xVars = getWorkSpaceTrajNames;

%
%==[3] Define the optimization setup.
%

%-- Parameter list (What role does this play in overall setup????)
%
ParamList = [];

%-- Cost Function
%
Cost = cost('xd^2+yd^2','trajectory');

%-- Constraints
%
Constr = optmodels.planarSE.initialCondition(gSym, g0)      ... 
    + optmodels.planarSE.finalPosition(gSym, pF)            ...
    + constraint.limits('v', uLims)                         ...
    + constraint.limits('thd', wLims);                      ...

doSquare = true;
if (doSquare)
  Constr = Constr + optmodels.planarSE.obsSquareApprox(gSym, rCent, r1safe, 8);
  disp('Does not draw square since classes not properly done yet!');
else
  Constr = Constr + optmodels.planarSE.obsCircle(gSym, rCent, r1safe);
end

Constr = Constr ...
         + optmodels.planarSE.dynamicsHilare(gpSym, gSym, 'v', 2/(8*pi) );

%-- Collocation Points, using Gaussian Quadrature formula
%
hl = tfinal;

numBreaks = 2*(ninterv+1);
breaks = linspace(0, hl, numBreaks);
gauss  = [-1 1]*sqrt(1/3)/2;
temp   = ((breaks(2:numBreaks)+breaks(1:numBreaks-1))/2);
temp   = temp(ones(1,length(gauss)),:) + gauss'*diff(breaks);
colpnts = temp(:).';

HL = [0 colpnts hl];

%-- Location of auto-generated functions.
%
pathName = './autogen';         % Save generated code to directory ...
probName = 'gaitHilare';        % Name of generated interface function.

%-- Create specification of the nonlinear programming problem.
%
nlp = ocp2nlp(TrajList, Cost,Constr, HL, ParamList, pathName, probName);
xlow = -Inf*ones(nlp.nIC,1);
xupp =  Inf*ones(nlp.nIC,1);

Time = linspace(0,1,100);

xval  = linspace(g0(1),pF(1),100);
yval  = linspace(g0(2),pF(2),100);  % Straight line
thval = linspace(g0(3),g0(3),100);  % Constant heading.

uval = linspace(u0,u0,100);  % Straight line

%-- Generate spline coefficients from initial guess.
xsp  = createGuess(x,Time,xval);
ysp  = createGuess(y,Time,yval);
vsp  = createGuess(v,Time,uval);
thsp = createGuess(th,Time,thval);

init = [xsp.coefs ysp.coefs thsp.coefs vsp.coefs];

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% IPOPT code
%%==[4] Run the solver.
%
tic;
ghSnopt = ipoptFunction(nlp);
toc;

[~,~,nobj, nlinConstr, nnlConstr]=ghSnopt(init');
nFreeVar=length(init);
nConstraint = nlinConstr+nnlConstr;
%% OPTRAGEN + IPOPT code 
profile on;
tic;
[x, info]=optragen_ipopt(ghSnopt,nobj,nFreeVar,nConstraint,init,xlow,xupp,[nlp.LinCon.lb;nlp.nlb],[nlp.LinCon.ub;nlp.nub]);
toc;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ==[5] Extract the trajectory from the solution.
%       Also snag points evaluated at specific times.
%
sp   = getTrajSplines(nlp,x);
[xSP, ySP, thSP, vSP] = deal(sp{:});

tgrid = linspace(min(HL),max(HL),ninterv*scale);

X  = fnval(xSP,tgrid);
Xd = fnval(fnder(xSP),tgrid);

Y  = fnval(ySP,tgrid);
Yd = fnval(fnder(ySP),tgrid);

Xcol = fnval(xSP,HL);
Ycol = fnval(ySP,HL);

V    = fnval(vSP,tgrid);

TH  = fnval(thSP,tgrid);
THd = fnval(fnder(thSP),tgrid);


%==[6] Display results.
%
fh = figure(1);
  clf;
  plot(tgrid, sqrt(Xd.^2+Yd.^2), 'b', ...
       tgrid, V, 'r');
  legend('velocity','input');
  set(fh, 'Name', 'Speed + Input');

%--Plot the trajectory and environment.
%

%-- Boundaries for the obstacle.
theta = 0:0.1:2*pi+0.1;
x = rCent(1) + r1*cos(theta);
y = rCent(2)+ r1*sin(theta);
xsafe = rCent(1) + r1safe*cos(theta);
ysafe = rCent(2) + r1safe*sin(theta);

fh = figure(2);
  clf;
  plot(X, Y,'b','LineWidth',1.5);           % Plot trajectory.
  hold on;
    % Plot the breakpoints (blue) and the collocation points (reD).
    plot(X(1:scale:end),Y(1:scale:end),'bo','MarkerSize', 8, 'LineWidth',1);
    plot(Xcol,Ycol,'ro','MarkerSize', 5, 'LineWidth',1);

    plot(x,y,'r',xsafe,ysafe,'k--');        % Plot the circular obstacle.
  hold off;
  axis equal;
  set(fh, 'Name', 'World'); 
  xlabel('x'); ylabel('y');

fh = figure(3);
  clf;
  subplot(1,2,1);
    speed = V;
    plot(tgrid, speed);xlabel('time'); ylabel('Speed');
    axis square;
    xlim([0, tfinal])
  subplot(1,2,2);
    angle = THd;
    plot(tgrid, angle);xlabel('time'); ylabel('Angular velocity (rad)');
    axis square;
    xlim([0, tfinal])
set(fh, 'Name', 'Input Signals'); 